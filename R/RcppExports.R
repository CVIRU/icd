# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Convert \code{mjr} and \code{mnr} vectors to single code
#'
#' In debug mode, will check that \code{mjr} and \code{mnr} are same length.
#' @template mjr
#' @template mnr
#' @template isShort
#' @examples
#' \dontrun{
#' n <- 5e6
#' mjrs <- as.character(sample(1:999, n, replace = TRUE))
#' mnrs <- as.character(sample(0:99, n, replace = TRUE))
#' microbenchmark::microbenchmark(
#'   icd9MajMinToCode(mjrs, mnrs, TRUE),
#'   icd9MajMinToCodeStd(mjrs, mnrs, TRUE),
#'   icd9MajMinToCodePrePadded(mjrs, mnrs, TRUE),
#'   times = 10
#' )
#' }
#' # std method about the same with O3 (4% faster, but no NA handling), but 50% quicker with O0
#' # std method without doing padding is 5 times quicker than previous...
#' @keywords internal manip
icd9MajMinToCode <- function(mjr, mnr, isShort) {
    .Call(`_icd_icd9MajMinToCode`, mjr, mnr, isShort)
}

#' @describeIn icd9MajMinToCode Same as \code{icd9MajMinToCode} but assume
#' codes are already trimmed and correctly padded with zeros, e.g. E001, V09,
#' 001. This version does handle NA values correctly. ' @keywords internal
icd9MajMinToCodePrePadded <- function(mjr, mnr, isShort) {
    .Call(`_icd_icd9MajMinToCodePrePadded`, mjr, mnr, isShort)
}

icd9MajMinToCodeStd <- function(mjr, mnr, isShort) {
    .Call(`_icd_icd9MajMinToCodeStd`, mjr, mnr, isShort)
}

icd9MajMinToShort <- function(mjr, mnr) {
    .Call(`_icd_icd9MajMinToShort`, mjr, mnr)
}

icd9MajMinToDecimal <- function(mjr, mnr) {
    .Call(`_icd_icd9MajMinToDecimal`, mjr, mnr)
}

#' append minor to major using std
#'
#' benefits from having reserve string size of 5
#' @keywords internal
icd9AppendMinors <- function(m, mnr, isShort) {
    invisible(.Call(`_icd_icd9AppendMinors`, m, mnr, isShort))
}

#' initialize a std::vector of strings with repeated value of the minor
#' @keywords internal
icd9MajMinToShortStd <- function(mjr, mnr) {
    .Call(`_icd_icd9MajMinToShortStd`, mjr, mnr)
}

icd9MajMinToShortSingleStd <- function(mjr, mnr) {
    .Call(`_icd_icd9MajMinToShortSingleStd`, mjr, mnr)
}

#' Set ICD short-form diagnosis code attribute
#'
#' Doing this in an R function doesn't work for 'void' equivalent, and does a
#' copy if the updated object is returned.
#' @examples
#' j <- "100"
#' attr(j, "icd_short_diag") <- TRUE
#' j
#' attr(j, "icd_short_diag") <- FALSE
#' j
#' icd:::attr_decimal_diag(j)
#' as.icd_decimal_diag(j)
#' # if pryr is installed, use address and refs to see what is going on
#' @keywords internal attribute
attr_decimal_diag <- function(x, value = TRUE) {
    invisible(.Call(`_icd_setDecimalDiag`, x, value))
}

#' @rdname as.icd_short_diag
#' @keywords internal attribute
attr_short_diag <- function(x, value = TRUE) {
    invisible(.Call(`_icd_setShortDiag`, x, value))
}

icd10cm_children_defined_cpp <- function(x) {
    .Call(`_icd_icd10cmChildrenDefined`, x)
}

#' @title prototype to do entire comorbidity calculation as a matrix multiplication
#' @description
#' The problem is that the matrices could be huge: the patient-icd matrix would
#' be millions of patient rows, and ~15000 columns for all AHRQ comorbidities.
#' @details
#' Several ways of reducing the problem: firstly, as with existing code, we can
#' drop any ICD codes from the map which are not in the patient data. With many
#' patients, this will be less effective as the long tail becomes apparent.
#' However, with the (small) Vermont data, we see ~15,000 codes being reduced to
#' 339.
#' @section Sparse matrices:
#' Using sparse matrices is another solution. Building
#' the initial matrix may become a significant part of the calculation, but once
#' done, the solution could be a simple matrix multiplication, which is
#' potentially highly optimized (Eigen, BLAS, GPU, etc.)
#' @section Eigen:
#' Eigen has parallel (non-GPU) optimized sparse row-major *
#' dense matrix. Patients-ICD matrix must be the row-major sparse one, so the
#' dense matrix is then the comorbidity map
#' \url{https://eigen.tuxfamily.org/dox/TopicMultiThreading.html}
#' @examples
#' # show how many discrete ICD codes there are in the AHRQ map, before reducing
#' # to the number which actually appear in a group of patient visitsben
#' library(magrittr)
#' sapply(icd::icd9_map_ahrq, length) %>% sum
#' \dontrun{
#' icd_comorbid_ahrq(vermont_dx %>% icd_wide_to_long, comorbid_fun = icd:::icd9ComorbidShortCpp)
#'
#' # to test Eigen sparse calcs, remove _alt line in .Rbuildignore, then these will be available.
#' Also, re-enable [[Rcpp::depends(RcppEigen)]]
#' microbenchmark::microbenchmark(
#'   icd_comorbid_ahrq(vermont_dx %>% icd_wide_to_long, comorbid_fun = icd:::icd9Comorbid_alt_MatMul),
#'   icd_comorbid_ahrq(vermont_dx %>% icd_wide_to_long, comorbid_fun = icd:::icd9ComorbidShortCpp),
#'   times = 25)
#' }
#' @keywords internal
icd9Comorbid_alt_MatMul <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9Comorbid_alt_MatMul`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

#' comorbidity search with sparse matrix result, OMP test version
#'
#' Much less memory competition in writing output. As an example the Vermont
#' data has 29,000 comorbidity flags (29 for each patient) Whereas only 2367
#' AHRQ comorbidity are positive, so under 10%.
#' @keywords internal
lookupComorbid_alt_SparseOmp <- function(vcdb, map) {
    .Call(`_icd_lookupComorbid_alt_SparseOmp`, vcdb, map)
}

#' @describeIn icd9Comorbid_alt_Taskloop Sparse comorbidity results with Eigen
#' @keywords internal
icd9Comorbid_alt_SparseOmp <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9Comorbid_alt_SparseOmp`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

#' @rdname icd_comorbid
#' @description \code{\link{Rcpp}} approach to comorbidity assignment with
#'   OpenMP and vector of integers strategy. It is very fast, and most time is
#'   now spent setting up the data to be passed in.
#' @keywords internal
icd9ComorbidShortCpp <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9ComorbidShortCpp`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

#' core search for ICD code in a map
#' @keywords internal
lookupComorbidByChunkFor <- function(vcdb, map, chunkSize, ompChunkSize, out) {
    invisible(.Call(`_icd_lookupComorbidByChunkFor`, vcdb, map, chunkSize, ompChunkSize, out))
}

#' Internal function to find ICD-10 parents
#'
#' Written in C++ for speed. There are no default arguments and there is no
#' value guessing.
#' @param x Character vector (not factor)
#' @template mapping
#' @template visit_name
#' @template icd_name
#' @seealso \url{https://github.com/s-u/fastmatch/blob/master/src/fastmatch.c}
#' @keywords internal
icd10_comorbid_parent_search_cpp <- function(x, map, visit_name, icd_name) {
    .Call(`_icd_icd10_comorbid_parent_search_cpp`, x, map, visit_name, icd_name)
}

#' comorbidity search with sparse matrix result
#'
#' Much less memory competition in writing output. As an example the Vermont
#' data has 29,000 comorbidity flags (29 for each patient) Whereas only 2367
#' AHRQ comorbidity are positive, so under 10%.
#' @keywords internal
lookupComorbid_alt_Sparse <- function(vcdb, map) {
    .Call(`_icd_lookupComorbid_alt_Sparse`, vcdb, map)
}

icd9Comorbid_alt_Sparse <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9Comorbid_alt_Sparse`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

#' alternate comorbidity search
#'
#' alternate version using much simplified with Openmp taskloop, only in OMP4.5
#'
#' @keywords internal
lookupComorbid_alt_ByChunkForTaskloop <- function(vcdb, map, out) {
    invisible(.Call(`_icd_lookupComorbid_alt_ByChunkForTaskloop`, vcdb, map, out))
}

#' Simpler comorbidity assignment
#'
#' Re-written without OpenMP initially, but structured more simply, with the motivation of
#' using modern compiler features and OpenMP 4.5 with 'taskloop' construct.
#' \url{https://developers.redhat.com/blog/2016/03/22/what-is-new-in-openmp-4-5-3/}
#'
#' # basic test
#' # use tests/testthat/helper-base.R for two_pts and two_map
#' icd_comorbid(two_pts, two_map, comorbid_fun = icd:::icd9Comorbid_alt_Taskloop)
#'
#' vermont_dx %>% icd_wide_to_long() -> vt
#' microbenchmark::microbenchmark(
#'   res1 <- icd_comorbid(vt, icd9_map_ahrq, comorbid_fun = icd:::icd9ComorbidShortCpp),
#'   res2 <- icd_comorbid(vt, icd9_map_ahrq, comorbid_fun = icd:::icd9Comorbid_alt_Taskloop),
#'   times = 50)
#' identical(res1, res2)
#'
#' @keywords internal
icd9Comorbid_alt_Taskloop <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9Comorbid_alt_Taskloop`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

#' @describeIn icd9Comorbid_alt_Taskloop Taskloop but finish with R transpose
#' @keywords internal
icd9Comorbid_alt_Taskloop2 <- function(icd9df, icd9Mapping, visitId, icd9Field, threads = 8L, chunk_size = 256L, omp_chunk_size = 1L) {
    .Call(`_icd_icd9Comorbid_alt_Taskloop2`, icd9df, icd9Mapping, visitId, icd9Field, threads, chunk_size, omp_chunk_size)
}

icd9MajMinToCode_alt_Old <- function(mjr, mnr, isShort) {
    .Call(`_icd_icd9MajMinToCode_alt_Old`, mjr, mnr, isShort)
}

#' @rdname convert
#' @keywords internal manip
icd9PartsToShort <- function(parts) {
    .Call(`_icd_icd9PartsToShort`, parts)
}

#' @rdname convert
#' @keywords internal manip
icd9PartsToDecimal <- function(parts) {
    .Call(`_icd_icd9PartsToDecimal`, parts)
}

icd9MajMinToParts <- function(mjr, mnr) {
    .Call(`_icd_icd9MajMinToParts`, mjr, mnr)
}

#' @rdname convert
#' @keywords internal manip
icd9ShortToPartsCpp <- function(icd9Short, mnrEmpty) {
    .Call(`_icd_icd9ShortToPartsCpp`, icd9Short, mnrEmpty)
}

#' @describeIn icd_decimal_to_parts Convert short ICD-10 code to parts
#' @export
#' @keywords internal manip
icd_short_to_parts.icd10 <- function(x, mnr_empty = "") {
    .Call(`_icd_icd10ShortToPartsCpp`, x, mnr_empty)
}

#' @rdname convert
#' @keywords internal manip
icd9DecimalToPartsCpp <- function(icd9Decimal, mnr_empty) {
    .Call(`_icd_icd9DecimalToPartsCpp`, icd9Decimal, mnr_empty)
}

#' @describeIn icd_decimal_to_parts Convert decimal ICD-10 code to parts. This
#'   shares almost 100% code with the ICD-9 version: someday combine the common
#'   code.
#' @export
#' @keywords internal manip
icd_decimal_to_parts.icd10 <- function(x, mnr_empty = "") {
    .Call(`_icd_icd10DecimalToPartsCpp`, x, mnr_empty)
}

icd9_short_to_decimal_cpp <- function(x) {
    .Call(`_icd_icd9ShortToDecimal`, x)
}

icd9_decimal_to_short_cpp <- function(x) {
    .Call(`_icd_icd9DecimalToShort`, x)
}

#' @describeIn icd_get_major Get major part of ICD-9 code, i.e. first three
#'   digits of numeric or V code, or first four digits of E code. This is the
#'   part before the decimal, when a decimal point is used.
#' @keywords internal manip
icd_get_major.icd9 <- function(x, short_code) {
    .Call(`_icd_icd9GetMajor`, x, short_code)
}

#' @name fastIntToString
#' @title Fast convert integer vector to character vector
#' @description Fast conversion from integer vector to character vector using C++
#' @param x vector of integers
#' @param bufferSize int if any input strings are longer than this number
#'   (default 16) there will be memory errors. No checks done for speed.
#' @examples
#' \dontrun{
#' pts <- generate_random_pts(1e7)
#' # conclusion: buffer size matters little (so default to be more generous),
#' # and 'Rcpp' version fastest.
#' microbenchmark::microbenchmark(fastIntToStringStd(pts$visit_id, buffer = 8),
#'                                fastIntToStringStd(pts$visit_id, buffer = 16),
#'                                fastIntToStringStd(pts$visit_id, buffer = 64),
#'                                fastIntToStringRcpp(pts$visit_id, buffer = 8),
#'                                fastIntToStringRcpp(pts$visit_id, buffer = 16),
#'                                fastIntToStringRcpp(pts$visit_id, buffer = 64),
#'                                as.character(pts$visit_id),
#'                                as_char_no_warn(pts$visit_id), times = 5)
#' }
#' @keywords internal
fastIntToStringStd <- function(x) {
    .Call(`_icd_fastIntToStringStd`, x)
}

#' @describeIn fastIntToString Same using \code{Rcpp}
fastIntToStringRcpp <- function(x) {
    .Call(`_icd_fastIntToStringRcpp`, x)
}

#' Guess whether codes are \code{short_code} or \code{decimal_code}
#'
#' The goal is to guess whether codes are \code{short_code} or
#' \code{decimal_code} form. Currently condense works, but not with the
#' \code{icd} look-up table currently in use. Of note, validation is a bit
#' different here, since we don't know the type until after we guess. We could
#' look for where both short_code and long are invalid, and otherwise assume
#' valid, even if the bulk are short_code. However, it may be more useful to
#' check validity after the guess.
#' @details Very quick heuristic, ploughs through ten million codes in less
#'   than one second and will stop more quickly if it finds a '.'.
#' @return single logical value, \code{TRUE} if input data are predominantly
#'   \code{short_code} type. If there is some uncertainty, then return
#'   \code{NA}.
#' @keywords internal
icd_guess_short <- function(x_, short_code = NULL, n = 1000L, icd_name = NULL) {
    .Call(`_icd_guessShortCompleteCpp`, x_, short_code, n, icd_name)
}

guessShortPlusFactorCpp <- function(x_, n) {
    .Call(`_icd_guessShortPlusFactorCpp`, x_, n)
}

#' Do elements of vector begin with V, E (or any other character)?
#'
#' Current returns a vector of \code{bool} which is not thread safe, or
#' particularly fast, although it is memory efficient in the standard
#' implementation. As of \code{icd9} (now known as \code{icd}) version 1.2,
#' this is not called by threaded code, but this could change, so beware! ASCII
#' spaces are trimmed from the start of the string before testing, but no other
#' white space
#' @param sv vector of strings
#' @param x \code{const char*} of choices of first character to match
#' @param invert single logical, if TRUE, negates the condition
#' @keywords internal
icd9_is_n_cpp <- function(sv) {
    .Call(`_icd_icd9_is_n_cpp`, sv)
}

#' @rdname icd9_is_n_cpp
#' @keywords internal
icd9_is_v_cpp <- function(sv) {
    .Call(`_icd_icd9_is_v_cpp`, sv)
}

#' @rdname icd9_is_n_cpp
#' @keywords internal
icd9_is_e_cpp <- function(sv) {
    .Call(`_icd_icd9_is_e_cpp`, sv)
}

icd_long_to_wide_cpp <- function(icd9df, visitId, icd9Field, aggregate = TRUE) {
    .Call(`_icd_icd9LongToWideCpp`, icd9df, visitId, icd9Field, aggregate)
}

#' Decompose a 'short' ICD code and insert the leading zeroes as needed.
#'
#' This should add leading zeroes when there is definitely no ambiguity,
#' e.g. V1. However V10 should not be altered, because V010 is a different
#' code. The goal is for this to be faster, but must be correct! Example in
#' \code{manip.cpp} has the benchmark code.
#' @keywords internal manip
icd9AddLeadingZeroes_alt_ShortSingle <- function(x) {
    .Call(`_icd_icd9AddLeadingZeroes_alt_ShortSingle`, x)
}

#' @describeIn icd9AddLeadingZeroes_alt_ShortSingle Directly apply
#' icd9AddLeadingZeroesShortSingle to each code without separating into parts
#' @keywords internal manip
icd9_add_leading_zeroes_alt_cpp <- function(x, short_code) {
    .Call(`_icd_icd9AddLeadingZeroes_alt_Direct`, x, short_code)
}

#' Simpler add leading zeroes without converting to parts and back
#' @keywords internal manip
icd9AddLeadingZeroesMajorSingle <- function(mjr) {
    .Call(`_icd_icd9AddLeadingZeroesMajorSingle`, mjr)
}

icd9AddLeadingZeroesMajorSingleStd <- function(m) {
    .Call(`_icd_icd9AddLeadingZeroesMajorSingleStd`, m)
}

icd9_add_leading_zeroes_major <- function(mjr) {
    .Call(`_icd_icd9AddLeadingZeroesMajor`, mjr)
}

#' @title Add leading zeroes to incomplete ICD-9 codes
#' @description Non-decimal ICD-9 codes with length<5 are often ambiguous. E.g.
#'   100 could be 1.00 10.0 or 100 if coded incorrectly. We must assume 100 is
#'   really 100
#' @param x Character vector of ICD-9 codes
#' @template short_code
#' @return character vector of ICD-9 codes with leading zeroes
#' @examples
#' if (require(microbenchmark)) {
#'   stopifnot(identical(
#'     icd:::icd9_add_leading_zeroes_alt_cpp(c("1", "E2", "V1", "E"), short_code = TRUE),
#'     icd:::icd9_add_leading_zeroes_cpp(c("1", "E2", "V1", "E"), short_code = TRUE)
#'     ))
#'
#'   bad_codes <- sample(c("E2", "V01", "1234", "12", "1", "E99", "E987", "V"),
#'                       size = 1e4, replace = TRUE)
#'   microbenchmark::microbenchmark(
#'     icd:::icd9_add_leading_zeroes_alt_cpp(bad_codes, short_code = TRUE),
#'     icd:::icd9_add_leading_zeroes_cpp(bad_codes, short_code = TRUE)
#'   )
#' }
#' @keywords internal manip
icd9_add_leading_zeroes_cpp <- function(x, short_code) {
    .Call(`_icd_icd9AddLeadingZeroes`, x, short_code)
}

#' Find child codes from vector of ICD-9 codes.
#'
#' Pure C++11 implementation using \code{unordered set} to find children of
#' given codes
#' @examples
#' \dontrun{
#' if (requireNamespace("microbenchmark")) {
#'   microbenchmark::microbenchmark(
#'     icd:::icd9ChildrenShort(c("001", 100:500), onlyReal = TRUE),
#'     icd:::icd9ChildrenShort_alt11(c("001", 100:500), onlyReal = TRUE),
#'     times = 5)
#'     # C++11 about 15% faster for this data
#' }
#' }
#' @keywords internal
icd9ChildrenShort_alt_11 <- function(icd9Short, onlyReal) {
    .Call(`_icd_icd9ChildrenShort_alt_11`, icd9Short, onlyReal)
}

#' C++ implementation of finding children of short codes
#' @examples
#' \dontrun{
#' library(microbenchmark)
#' microbenchmark(icd9ChildrenShort("001", T), icd9ChildrenShortStd("001", T), times = 100)
#' microbenchmark(icd9ChildrenShort(c("001", 100:400), T),
#'                icd9ChildrenShortUnordered(c("001", 100:400), T),
#'                icd9ChildrenShortStd(c("001", 100:400), T),
#'                times = 10)
#' }
#' # un-ordered set much faster, but may still need to sort result
#' @keywords internal
icd9ChildrenShort_alt_Std <- function(icd9Short, onlyReal) {
    .Call(`_icd_icd9ChildrenShort_alt_Std`, icd9Short, onlyReal)
}

icd9Children_alt_ShortNoNaUnordered <- function(icd9Short, onlyReal) {
    .Call(`_icd_icd9Children_alt_ShortNoNaUnordered`, icd9Short, onlyReal)
}

icd9ExpandMinorStd <- function(mnr, isE) {
    .Call(`_icd_icd9ExpandMinorStd`, mnr, isE)
}

icd9_expand_minor_wrap <- function(mnr, isE) {
    .Call(`_icd_icd9ExpandMinor`, mnr, isE)
}

icd9ChildrenShort <- function(icd9Short, onlyReal) {
    .Call(`_icd_icd9ChildrenShort`, icd9Short, onlyReal)
}

icd9ChildrenShortUnordered <- function(icd9Short, onlyReal) {
    .Call(`_icd_icd9ChildrenShortUnordered`, icd9Short, onlyReal)
}

icd9ChildrenDecimalCpp <- function(icd9Decimal, onlyReal) {
    .Call(`_icd_icd9ChildrenDecimalCpp`, icd9Decimal, onlyReal)
}

icd9ChildrenCpp <- function(icd9, isShort, onlyReal = TRUE) {
    .Call(`_icd_icd9ChildrenCpp`, icd9, isShort, onlyReal)
}

#' @title match ICD9 codes
#' @description Finds children of \code{icd9Reference} and looks for \code{icd9} in the
#'   resulting vector.
#' @templateVar icd9AnyName "icd9,icd9Reference"
#' @template icd9-any
#' @template short_code
#' @param isShortReference logical, see argument \code{short_code}
#' @return logical vector
#' @keywords internal
icd_in_reference_code <- function(icd, icd_reference, short_code, short_reference = TRUE) {
    .Call(`_icd_icd_in_reference_code`, icd, icd_reference, short_code, short_reference)
}

trimLeftCpp <- function(s) {
    .Call(`_icd_trimLeftCpp`, s)
}

strimCpp <- function(s) {
    .Call(`_icd_strimCpp`, s)
}

trimCpp <- function(sv) {
    .Call(`_icd_trimCpp`, sv)
}

get_omp_cores <- function() {
    .Call(`_icd_getOmpCores`)
}

get_omp_max_threads <- function() {
    .Call(`_icd_getOmpMaxThreads`)
}

get_omp_threads <- function() {
    .Call(`_icd_getOmpThreads`)
}

debug_parallel_env <- function() {
    invisible(.Call(`_icd_debug_parallel_env`))
}

debug_parallel <- function() {
    invisible(.Call(`_icd_debug_parallel`))
}

randomMajorCpp <- function(n) {
    .Call(`_icd_randomMajorCpp`, n)
}

#' @rdname icd9RandomShort
#' @keywords internal
icd9RandomShortN <- function(n = 5L) {
    .Call(`_icd_icd9RandomShortN`, n)
}

#' @rdname icd9RandomShort
#' @keywords internal
icd9RandomShortV <- function(n = 5L) {
    .Call(`_icd_icd9RandomShortV`, n)
}

#' @rdname icd9RandomShort
#' @keywords internal
icd9RandomShortE <- function(n = 5L) {
    .Call(`_icd_icd9RandomShortE`, n)
}

#' Generate random short-form ICD-9 codes
#'
#' Quick pseudo-random by picking numeric, 'V' or 'E' based on modulo three of
#' the number
#' @keywords internal
icd9RandomShort <- function(n = 5L) {
    .Call(`_icd_icd9RandomShort`, n)
}

valgrindCallgrindStart <- function(zerostats = FALSE) {
    .Call(`_icd_valgrindCallgrindStart`, zerostats)
}

valgrindCallgrindStop <- function() {
    .Call(`_icd_valgrindCallgrindStop`)
}

icd9_sort_cpp <- function(x) {
    .Call(`_icd_icd9SortCpp`, x)
}

icd9_order_cpp <- function(x) {
    .Call(`_icd_icd9OrderCpp`, x)
}

#' fast expand of logical matrix to add rows filled with false
#' @examples
#' nrow = 1e5
#' a <- matrix(rnorm(nrow * 30) < 0.5, nrow = nrow, ncol = 30)
#' identical(rbind(a, matrix(FALSE, nrow = 1e5, ncol = 30)), icd:::rbind_with_empty(a, nrow))
#' microbenchmark::microbenchmark(
#'   rbind(a, matrix(FALSE, nrow = 1e5, ncol = 30)),
#'   icd:::rbind_with_empty(a, nrow))
#' )
#' @keywords internal
rbind_with_empty <- function(a, b_rows) {
    .Call(`_icd_rbind_with_empty`, a, b_rows)
}

#' fast factor generation test
#' @examples
#' \dontrun{
#' codes <- unname(unlist(icd9_map_ahrq))
#' codes <- c(codes, icd:::randomMajorCpp(1e7))
#' microbenchmark::microbenchmark(
#'   icd:::factor_fast(codes),
#'   icd:::factor_nosort(codes),
#'   factor(codes),
#'   times = 10
#'   )
#' # the R factor_nosort is about as fast as Rcpp version
#' }
#' @keywords internal
factor_fast <- function(x) {
    .Call(`_icd_factor_fast`, x)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_icd_RcppExport_registerCCallable', PACKAGE = 'icd')
})
